<!-- Creator     : groff version 1.20 -->
<!-- CreationDate: Wed Sep 27 17:45:22 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MEMKIND</title>

</head>
<body>

<h1 align="center">MEMKIND</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#KINDS">KINDS</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#STATIC LINKING">STATIC LINKING</a><br>
<a href="#KNOWN ISSUES">KNOWN ISSUES</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">memkind &minus;
Heap manager that enables allocations to memory with
different properties. <br>
This header expose EXPERIMENTAL API in except of STANDARD
API placed in section LIBRARY VERSION. API Standards are
described below in this man page.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;memkind.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>ERROR
HANDLING: <br>
void memkind_error_message(int</b> <i>err</i><b>, char</b>
<i>*msg</i><b>, size_t</b> <i>size</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>HEAP
MANAGEMENT: <br>
void *memkind_malloc(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>size</i><b>); <br>
void *memkind_calloc(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>num</i><b>, size_t</b> <i>size</i><b>); <br>
void *memkind_realloc(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>, size_t</b> <i>size</i><b>); <br>
int memkind_posix_memalign(memkind_t</b> <i>kind</i><b>,
void</b> <i>**memptr</i><b>, size_t</b> <i>alignment</i><b>,
size_t</b> <i>size</i><b>); <br>
void memkind_free(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
MANAGMENT: <br>
int memkind_create_pmem(const char</b> <i>*dir</i><b>,
size_t</b> <i>max_size</i><b>, memkind_t</b>
<i>*kind</i><b>); <br>
int memkind_check_available(memkind_t</b>
<i>kind</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>DECORATORS:
<br>
void memkind_malloc_pre(memkind_t</b> <i>*kind</i><b>,
size_t</b> <i>*size</i><b>); <br>
void memkind_malloc_post(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>size</i><b>, void</b> <i>**result</i><b>);
<br>
void memkind_calloc_pre(memkind_t</b> <i>*kind</i><b>,
size_t</b> <i>*nmemb</i><b>, size_t</b> <i>*size</i><b>);
<br>
void memkind_calloc_post(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>nmemb</i><b>, size_t</b> <i>size</i><b>,
void</b> <i>**result</i><b>); <br>
void memkind_posix_memalign_pre(memkind_t</b>
<i>*kind</i><b>, void</b> <i>**memptr</i><b>, size_t</b>
<i>*alignment</i><b>, size_t</b> <i>*size</i><b>); <br>
void memkind_posix_memalign_post(memkind_t</b>
<i>kind</i><b>, void</b> <i>**memptr</i><b>, size_t</b>
<i>alignment</i><b>, size_t</b> <i>size</i><b>, int</b>
<i>*err</i><b>); <br>
void memkind_realloc_pre(memkind_t</b> <i>*kind</i><b>,
void</b> <i>**ptr</i><b>, size_t</b> <i>*size</i><b>); <br>
void memkind_realloc_post(memkind_t</b> <i>kind</i><b>,
void</b> <i>*ptr</i><b>, size_t</b> <i>size</i><b>, void</b>
<i>**result</i><b>); <br>
void memkind_free_pre(memkind_t</b> <i>*kind</i><b>,
void</b> <i>**ptr</i><b>); <br>
void memkind_free_post(memkind_t</b> <i>kind</i><b>,
void</b> <i>*ptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>LIBRARY
VERSION: <br>
int memkind_get_version();</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_error_message</b>()
converts an error number <i>err</i> returned by a member of
the memkind interface to an error message <i>msg</i> where
the maximum size of the message is passed by the <i>size</i>
parameter.</p>

<p style="margin-left:11%; margin-top: 1em"><b>HEAP
MANAGMENT:</b> <br>
The functions described in this section define a heap
manager with an interface modeled on the ISO C standard
API&rsquo;s, except that the user must specify the
<i>kind</i> of memory with the first argument to each
function. See the <b>KINDS</b> section below for a full
description of the implemented kinds.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_malloc</b>()
allocates <i>size</i> bytes of uninitialized memory of the
specified <i>kind</i>. The allocated space is suitably
aligned (after possible pointer coercion) for storage of any
type of object. If <i>size</i> is 0, then
<b>memkind_malloc</b>() returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_calloc</b>()
allocates space for <i>num</i> objects each <i>size</i>
bytes in length in memory of the specified <i>kind</i>. The
result is identical to calling <b>memkind_malloc</b>() with
an argument of <i>num</i>*<i>size</i>, with the exception
that the allocated memory is explicitly initialized to zero
bytes. If <i>num</i> or <i>size</i> is 0, then
<b>memkind_calloc</b>() returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_realloc</b>()
changes the size of the previously allocated memory
referenced by <i>ptr</i> to <i>size</i> bytes of the
specified <i>kind</i>. The contents of the memory are
unchanged up to the lesser of the new and old sizes. If the
new size is larger, the contents of the newly allocated
portion of the memory are undefined. Upon success, the
memory referenced by <i>ptr</i> is freed and a pointer to
the newly allocated high bandwidth memory is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
memkind_realloc</b>() may move the memory allocation,
resulting in a different return value than <i>ptr</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>ptr</i>
is NULL, the <b>memkind_realloc</b>() function behaves
identically to <b>memkind_malloc</b>() for the specified
size. The address <i>ptr</i>, if not NULL, must have been
returned by a previous call to <b>memkind_malloc</b>(),
<b>memkind_calloc</b>(), <b>memkind_realloc</b>(), or
<b>memkind_posix_memalign</b>() with the same <i>kind</i> as
specified to the call to <b>memkind_realloc</b>().
Otherwise, if <i>memkind_free(kind, ptr)</i> was called
before, undefined behavior occurs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_posix_memalign</b>()
allocates <i>size</i> bytes of memory of a specified
<i>kind</i> such that the allocation&rsquo;s base address is
an even multiple of <i>alignment</i>, and returns the
allocation in the value pointed to by <i>memptr</i>. The
requested <i>alignment</i> must be a power of 2 at least as
large as <i>sizeof(void *)</i>. If <i>size</i> is 0, then
<b>memkind_posix_memalign</b>() returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_free</b>()
causes the allocated memory referenced by <i>ptr</i> to be
made available for future allocations. This pointer must
have been returned by a previous call to
<b>memkind_malloc</b>(), <b>memkind_calloc</b>(),
<b>memkind_realloc</b>(), or
<b>memkind_posix_memalign</b>(). Otherwise, if
<i>memkind_free(kind, ptr)</i> was already called before,
undefined behavior occurs. If <i>ptr</i> is NULL, no
operation is performed. The value of <b>MEMKIND_DEFAULT</b>
can be given as the <i>kind</i> for all buffers allocated by
a kind that leverages the jemalloc allocator. In cases where
the kind is unknown in the context of the call to
<b>memkind_free</b>() <b>0</b> can be given as the
<i>kind</i> specified to <b>memkind_free</b>() but this will
require a look up that can be bypassed by specifying a
non-zero value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
MANAGEMENT:</b> <br>
There are built-in kinds that are always available, and
these are enumerated in the <b>KINDS</b> section. The user
can also create their own kinds of memory. This section
describes the API&rsquo;s that enable the tracking of the
different kinds of memory and determining their
properties.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_create_pmem</b>()
is a convenience function used to create a file-backed kind
of memory. It allocates a temporary file in the given
directory <i>dir</i>. The file is created in a fashion
similar to <b>tmpfile</b>(3), so that the file name does not
appear when the directory is listed and the space is
automatically freed when the program terminates. The file is
truncated to a size of <i>max_size</i> bytes and the
resulting space is memory-mapped. <br>
Note that the actual file system space is not allocated
immediately, but only on a call to
<b>memkind_pmem_mmap</b>() (see <b>memkind_pmem</b>(3)).
This allows to create a pmem memkind of a pretty large size
without the need to reserve in advance the corresponding
file system space for the entire heap. The minimum
<i>max_size</i> value allowed by the library is defined in
<b>&lt;memkind_pmem.h&gt;</b> as
<b>MEMKIND_PMEM_MIN_SIZE</b>. Calling
<b>memkind_create_pmem</b>() with a size smaller than that
will return an error. The maximum allowed size is not
limited by <b>memkind</b>, but by the file system specified
by the <i>dir</i> argument. The <i>max_size</i> passed in is
the raw size of the memory pool and <b>jemalloc</b> will use
some of that space for its own metadata.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_check_available</b>()
Returns a zero if the specified <i>kind</i> is available or
an error code from the <b>ERRORS</b> section if it is
not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DECORATORS:</b>
<br>
The memkind library enables the user to define decorator
functions that can be called before and after each memkind
heap management API. The decorators that are called at the
beginning of the function end are named after that function
with <i>_pre</i> appended to the name, and those that are
called at the end of the function are named after that
function with <i>_post</i> appended to the name. These are
weak symbols, and if they are not present at link time they
are not called. The memkind library does not define these
symbols which are reserved for user definition. These
decorators can be used to track calls to the heap management
interface or to modify parameters. The decorators that are
called at the beginning of the allocator pass all inputs by
reference, and the decorators that are called at the end of
the allocator pass the output by reference. This enables the
modification of the input and output of each heap management
function by the decorators.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LIBRARY
VERSION</b> <br>
The memkind library version scheme consist major, minor and
patch numbers separated by dot. Combining those numbers, we
got the following representation: <br>
major.minor.patch, where:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-major number is incremented whenever API is changed
(loss of backward compatibility),</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-minor number is incremented whenever additional
extensions are introduced, or behavior has been changed,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-patch number is incremented whenever small bug fixes
are added.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">memkind library
provide numeric representation of the version by exposing
the following API: <br>
int memkind_get_version() return version number represented
by a single integer number, obtained from the formula: <br>
major * 1000000 + minor * 1000 + patch</p>

<p style="margin-left:11%; margin-top: 1em">Note: major
&lt; 1 means unstable API.</p>

<p style="margin-left:11%; margin-top: 1em">API standards:
<br>
-STANDARD API, API is considered as stable <br>
-NON-STANDARD API, API is considered as stable, however this
is not a standard way to use memkind <br>
-EXPERIMENTAL API, API is considered as unstable and the
subject to change</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_calloc</b>(),
<b>memkind_malloc</b>(), and <b>memkind_realloc</b>(),
return the pointer to the allocated memory, or NULL if the
request fails. <b>memkind_free</b>() and
<b>memkind_error_message</b>() do not have return values.
All other memkind API&rsquo;s return 0 upon success, and an
error code defined in the ERRORS section upon failure. The
memkind library avoids setting <i>errno</i> directly, but
calls to underlying libraries and system calls may set
<i>errno</i>.</p>

<h2>KINDS
<a name="KINDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
kinds of memory <b><br>
MEMKIND_DEFAULT</b></p>

<p style="margin-left:22%;">Default allocation using
standard memory and default page size.</p>

<p style="margin-left:11%;"><b>MEMKIND_HUGETLB</b></p>

<p style="margin-left:22%;">Allocate from standard memory
using huge pages. Note: This kind requires huge pages
configuration described in SYSTEM CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>MEMKIND_GBTLB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Allocate from standard memory
using 1GB chunks backed by huge pages. Note: This kind
requires huge pages configuration described in SYSTEM
CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>MEMKIND_INTERLEAVE</b></p>

<p style="margin-left:22%;">Allocate pages interleaved
across all NUMA nodes with transparent huge pages
disabled.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW</b></p>

<p style="margin-left:22%;">Allocate from the closest high
bandwidth memory NUMA node at time of allocation. If there
is not enough high bandwidth memory to satisfy the request
<i>errno</i> is set to ENOMEM and the allocated pointer is
set to NULL.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_ALL</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except decision regarding closest NUMA node is postponed
until the time of first write.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_HUGETLB</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except the allocation is backed by huge pages. Note: This
kind requires huge pages configuration described in SYSTEM
CONFIGURATION section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_ALL_HUGETLB</b></p>

<p style="margin-left:22%;">Combination of
<b>MEMKIND_HBW_ALL</b> and <b>MEMKIND_HBW_HUGETLB</b>
properties. Note: This kind requires huge pages
configuration described in SYSTEM CONFIGURATION section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except that if there is not enough high bandwidth memory to
satisfy the request, the allocation will fall back on
standard memory.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED_HUGETLB</b></p>

<p style="margin-left:22%;">Same as
<b>MEMKIND_HBW_PREFERRED</b> except the allocation is backed
by huge pages. Note: This kind requires huge pages
configuration described in SYSTEM CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_GBTLB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except the allocation is backed by 1GB chunks of huge pages.
Note that <i>size</i> can take on any value, but full
gigabyte pages will allocated for each request, so remainder
of the last page will be wasted. This kind requires huge
pages configuration described in SYSTEM CONFIGURATION
section.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED_GBTLB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Same as
<b>MEMKIND_HBW_GBTLB</b> except that if there is not enough
high bandwidth memory to satisfy the request, the allocation
will fall back on standard memory. Note: This kind requires
huge pages configuration described in SYSTEM CONFIGURATION
section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_INTERLEAVE</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except that the pages that support the allocation are
interleaved across all high bandwidth nodes and transparent
huge pages are disabled.</p>

<p style="margin-left:11%;"><b>MEMKIND_REGULAR</b></p>

<p style="margin-left:22%;">Allocate from regular memory
using the default page size. Regular means general purpose
memory from the NUMA nodes containing CPUs.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_posix_memalign</b>()</p>

<p style="margin-left:22%;">returns the one of the POSIX
standard error codes <b>EINVAL</b> or <b>ENOMEM</b> as
defined in <i>&lt;errno.h&gt;</i> if an error occurs (these
have positive values). If the <i>alignment</i> parameter is
not a power of two, or is not a multiple of <i>sizoeof(void
*)</i>, then <b>EINVAL</b> is returned. If there is
insufficient memory to satisfy the request then
<b>ENOMEM</b> is returned.</p>

<p style="margin-left:11%; margin-top: 1em">All functions
other than <b>memkind_posix_memalign</b>() which have an
integer return type return one of the negative error codes
as defined in <i>&lt;memkind.h&gt;</i> and described below.
<b><br>
MEMKIND_ERROR_UNAVAILABLE</b></p>

<p style="margin-left:22%;">Requested memory kind is not
available</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MBIND</b></p>

<p style="margin-left:22%;">Call to <b>mbind</b>(2)
failed</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MMAP</b></p>

<p style="margin-left:22%;">Call to <b>mmap</b>(2)
failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_MALLOC</b></p>

<p style="margin-left:22%;">Call to jemalloc&rsquo;s
<b>malloc</b>() failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_ALLOCM</b></p>

<p style="margin-left:22%;">Call to jemalloc&rsquo;s
<b>allocm</b>() failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_ENVIRON</b></p>

<p style="margin-left:22%;">Error parsing environment
variable (MEMKIND_*)</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_INVALID</b></p>

<p style="margin-left:22%;">Invalid input arguments to
memkind routine</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/usr/bin/memkind-hbw-nodes</i></p>

<p style="margin-left:22%;">Prints a comma separated list
of high bandwidth nodes.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND_HBW_NODES</b></p>

<p style="margin-left:22%;">This environment variable is a
comma separated list of NUMA nodes that are treated as high
bandwidth. Uses the <i>libnuma</i> routine
<b>numa_parse_nodestring</b>() for parsing, so the syntax
described in the <b>numa</b>(3) man page for this routine
applies: e.g 1-3,5 is a valid setting.</p>


<p style="margin-left:11%;"><b>MEMKIND_ARENA_NUM_PER_KIND</b></p>

<p style="margin-left:22%;">This environment variable
allows leveraging internal mechanism of the library for
setting number of arenas per kind. Value should be a
positive integer (not greater than INT_MAX defined in
limits.h). The user should set the value based on the
characteristics of application that is using the library.
Higher value can provide better performance in extremely
multithreaded applications at the cost of memory overhead.
See section &quot;IMPLEMENTATION NOTES&quot; of
<b>jemalloc</b>(3) for more details about arenas.</p>

<p style="margin-left:11%;"><b>MEMKIND_HOG_MEMORY</b></p>

<p style="margin-left:22%;">Controls behavior of memkind
with regards to returning memory to underlaying OS. Setting
<b>MEMKIND_HOG_MEMORY</b> to &quot;1&quot; causes memkind to
not release memory to OS in anticipation of memory reuse
soon. This will improve latency of &rsquo;free&rsquo;
operations but increase memory usage.</p>

<p style="margin-left:11%;"><b>MEMKIND_DEBUG</b></p>

<p style="margin-left:22%;">Controls logging mechanism in
memkind. Setting <b>MEMKIND_DEBUG</b> to &quot;1&quot;
enables printing messages like errors and general
informations about environment to <i>stderr.</i></p>


<p style="margin-left:11%;"><b>MEMKIND_HEAP_MANAGER</b></p>

<p style="margin-left:22%;">Controls heap management
behavior in memkind library by switching to one of the
available heap managers. <br>
Values: <br>
JEMALLOC &acirc; sets the jamalloc heap manager <br>
TBB &acirc; sets the Intel Threading Building Blocks heap
manager. This option requires installed <br>
Intel Threading Building Blocks library. If the
MEMKIND_HEAP_MANAGER is not set than the jemalloc heap
manager will be used by default.</p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB (HUGETLB) need allocated huge pages in the
kernel&rsquo;s huge page pool. <b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
/proc/sys/vm/nr_hugepages file. Proposed way of setting
hugepages is: &quot;sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;&quot;. More
informations can be found here:
https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</p>

<h2>STATIC LINKING
<a name="STATIC LINKING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When linking
statically against memkind, libmemkind.a should be used <br>
together with its dependencies libnuma and pthread. Pthread
can be <br>
linked by adding /usr/lib64/libpthread.a as a dependency
(exact path <br>
may vary). Typically libnuma will need to be compiled from
sources to <br>
use it as a static dependency. libnuma can be reached on
github: <br>
https://github.com/numactl/numactl</p>

<h2>KNOWN ISSUES
<a name="KNOWN ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>HUGETLB
(huge pages)</b></p>

<p style="margin-left:22%;">There might be some overhead in
huge pages consumption caused by heap management. If your
allocation fails because of OOM, please try to allocate
extra huge pages (e.g. 8 huge pages).</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2014 - 2017 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>malloc</b>(3),
<b>numa</b>(3), <b>numactl</b>(8), <b>mbind</b>(2),
<b>mmap</b>(2), <b>move_pages</b>(2), <b>jemalloc</b>(3),
<b>memkind_default</b>(3), <b>memkind_arena</b>(3),
<b>memkind_hbw</b>(3), <b>memkind_hugetlb</b>(3),
<b>memkind_pmem</b>(3)</p>
<hr>
</body>
</html>
